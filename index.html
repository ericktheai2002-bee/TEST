<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Trading Dashboard EthernAI</title>
    <!-- Librerías de visualización -->
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/locale/es.min.js"></script>
    <style>
        :root {
            --primary-bg: #0a0e17;
            --secondary-bg: #121827;
            --card-bg: #1a1f2e;
            --accent-blue: #2563eb;
            --accent-green: #10b981;
            --accent-purple: #8b5cf6;
            --accent-cyan: #06b6d4;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --grid-color: #1e293b;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--primary-bg);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--grid-color);
            margin-bottom: 20px;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-cyan));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
        }

        .logo::before {
            content: "◈";
            margin-right: 10px;
            font-size: 28px;
        }

        .controls {
            display: flex;
            gap: 15px;
        }

        select {
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            border: 1px solid var(--grid-color);
            padding: 8px 15px;
            border-radius: 5px;
            outline: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:hover {
            border-color: var(--accent-blue);
        }

        .kpi-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .kpi-card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            position: relative;
            overflow: hidden;
            transition: transform 0.3s ease;
        }

        .kpi-card:hover {
            transform: translateY(-5px);
        }

        .kpi-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-cyan));
        }

        .kpi-title {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 10px;
        }

        .kpi-value {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .kpi-change {
            display: flex;
            align-items: center;
            font-size: 14px;
        }

        .positive {
            color: var(--accent-green);
        }

        .negative {
            color: var(--danger);
        }

        .charts-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .chart-title {
            font-size: 18px;
            font-weight: 600;
        }

        .chart-actions {
            display: flex;
            gap: 10px;
        }

        .chart {
            height: 350px;
        }

        .volume-chart {
            grid-column: 1 / -1;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            flex-direction: column;
            gap: 15px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--grid-color);
            border-top: 5px solid var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .glow {
            position: absolute;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: radial-gradient(var(--accent-purple), transparent 70%);
            opacity: 0.05;
            filter: blur(40px);
            z-index: -1;
        }

        .glow-1 {
            top: 10%;
            left: 10%;
        }

        .glow-2 {
            bottom: 10%;
            right: 10%;
            background: radial-gradient(var(--accent-cyan), transparent 70%);
        }

        footer {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
            font-size: 14px;
            border-top: 1px solid var(--grid-color);
            margin-top: 30px;
        }

        @media (max-width: 1200px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .kpi-cards {
                grid-template-columns: 1fr 1fr;
            }
            
            header {
                flex-direction: column;
                gap: 15px;
            }
            
            .controls {
                width: 100%;
                justify-content: center;
            }
        }

        @media (max-width: 576px) {
            .kpi-cards {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="glow glow-1"></div>
    <div class="glow glow-2"></div>
    
    <div class="container">
        <header>
            <div class="logo">Trading Analytics by EthernAI</div>
            <div class="controls">
                <select id="symbol-selector">
                    <option value="">Cargando símbolos...</option>
                </select>
                <select id="time-filter">
                    <option value="5">Last 5 Days</option>
                    <option value="15" selected>Last 15 Days</option>
                    <option value="30">Last Month</option>
                </select>
            </div>
        </header>
        
        <div class="kpi-cards">
            <div class="kpi-card">
                <div class="kpi-title">PRECIO ACTUAL</div>
                <div class="kpi-value" id="current-price">--</div>
                <div class="kpi-change" id="price-change">--</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-title">VOLUMEN (24H)</div>
                <div class="kpi-value" id="current-volume">--</div>
                <div class="kpi-change" id="volume-change">--</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-title">PRONÓSTICO PROPHET</div>
                <div class="kpi-value" id="prophet-forecast">--</div>
                <div class="kpi-change" id="prophet-change">--</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-title">PRONÓSTICO RNN</div>
                <div class="kpi-value" id="rnn-forecast">--</div>
                <div class="kpi-change" id="rnn-change">--</div>
            </div>
        </div>
        
        <div class="charts-container">
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">PRECIO HISTÓRICO</div>
                    <div class="chart-actions">
                        <!-- Los botones de zoom se añadirán dinámicamente -->
                    </div>
                </div>
                <div id="price-chart" class="chart"></div>
            </div>
            
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">COMPARATIVO DE PRONÓSTICOS (Días 15-17)</div>
                </div>
                <div id="forecast-chart" class="chart"></div>
            </div>
            
            <div class="chart-card volume-chart">
                <div class="chart-header">
                    <div class="chart-title">VOLUMEN DE OPERACIONES</div>
                </div>
                <div id="volume-chart" class="chart"></div>
            </div>
        </div>
    </div>
    
    <footer>
        Quantum Trading Dashboard EthernAI; 2025 - Real Time Data -1
    </footer>

    <script>
        // Variables globales
        let historicalData = null;
        let forecastData = null;
        let currentSymbol = '';
        let priceChart = null;
        let forecastChart = null;
        let volumeChart = null;

        // Configuración de colores para el tema oscuro
        const chartColors = {
            grid: '#1e293b',
            text: '#cbd5e1',
            line: '#2563eb',
            area: 'rgba(37, 99, 235, 0.2)',
            volume: 'rgba(16, 185, 129, 0.7)',
            prophet: '#8b5cf6',
            linear: '#06b6d4',
            arima: '#f59e0b',
            rnn: '#ef4444'
        };

        // Datos de pronóstico de ejemplo para cuando la carga falle
        const sampleForecastData = [
            {symbol: "AAPL", Fecha: "2023-11-15", Prophet_Forecast: 185.32, Regresion_Linear_Forecast: 184.76, ARIMA_Forecast: 186.21, RNN_Forecast: 187.45},
            {symbol: "AAPL", Fecha: "2023-11-16", Prophet_Forecast: 186.78, Regresion_Linear_Forecast: 185.23, ARIMA_Forecast: 187.54, RNN_Forecast: 188.32},
            {symbol: "AAPL", Fecha: "2023-11-17", Prophet_Forecast: 187.45, Regresion_Linear_Forecast: 186.12, ARIMA_Forecast: 188.67, RNN_Forecast: 189.21},
            {symbol: "MSFT", Fecha: "2023-11-15", Prophet_Forecast: 367.45, Regresion_Linear_Forecast: 366.28, ARIMA_Forecast: 368.92, RNN_Forecast: 369.87},
            {symbol: "MSFT", Fecha: "2023-11-16", Prophet_Forecast: 369.12, Regresion_Linear_Forecast: 367.89, ARIMA_Forecast: 370.45, RNN_Forecast: 371.23},
            {symbol: "MSFT", Fecha: "2023-11-17", Prophet_Forecast: 370.89, Regresion_Linear_Forecast: 369.45, ARIMA_Forecast: 372.12, RNN_Forecast: 372.98},
            {symbol: "GOOGL", Fecha: "2023-11-15", Prophet_Forecast: 132.45, Regresion_Linear_Forecast: 131.87, ARIMA_Forecast: 133.21, RNN_Forecast: 134.12},
            {symbol: "GOOGL", Fecha: "2023-11-16", Prophet_Forecast: 133.78, Regresion_Linear_Forecast: 132.98, ARIMA_Forecast: 134.56, RNN_Forecast: 135.34},
            {symbol: "GOOGL", Fecha: "2023-11-17", Prophet_Forecast: 134.92, Regresion_Linear_Forecast: 133.87, ARIMA_Forecast: 135.78, RNN_Forecast: 136.45},
            {symbol: "TSLA", Fecha: "2023-11-15", Prophet_Forecast: 234.56, Regresion_Linear_Forecast: 233.45, ARIMA_Forecast: 235.67, RNN_Forecast: 236.78},
            {symbol: "TSLA", Fecha: "2023-11-16", Prophet_Forecast: 236.78, Regresion_Linear_Forecast: 235.23, ARIMA_Forecast: 237.89, RNN_Forecast: 238.91},
            {symbol: "TSLA", Fecha: "2023-11-17", Prophet_Forecast: 238.12, Regresion_Linear_Forecast: 236.78, ARIMA_Forecast: 239.45, RNN_Forecast: 240.12}
        ];

        // Inicialización
        document.addEventListener('DOMContentLoaded', function() {
            moment.locale('es');
            loadData();
            
            // Event listeners para los controles
            document.getElementById('symbol-selector').addEventListener('change', function() {
                currentSymbol = this.value;
                updateAllCharts();
            });
            
            document.getElementById('time-filter').addEventListener('change', function() {
                updateAllCharts();
            });
        });

        // Cargar datos desde GitHub
        async function loadData() {
            try {
                // Mostrar estado de carga
                showLoadingState();
                
                // URLs de los datos
                const historicalUrl = 'https://raw.githubusercontent.com/ericktheai2002-bee/TEST/main/multi_stock_intraday_data.json';
                const forecastUrl = 'https://raw.githubusercontent.com/ericktheai2002-bee/TEST/main/consolidated_forecast.json';
                
                // Cargar ambos conjuntos de datos simultáneamente
                const [historicalResponse, forecastResponse] = await Promise.all([
                    fetch(historicalUrl),
                    fetch(forecastUrl)
                ]);
                
                if (!historicalResponse.ok) {
                    throw new Error('Error al cargar los datos históricos');
                }
                
                historicalData = await historicalResponse.json();
                
                // Procesar datos históricos
                processHistoricalData();
                
                // Procesar datos de pronóstico (usar muestra si hay error)
                if (forecastResponse.ok) {
                    forecastData = await forecastResponse.json();
                    processForecastData();
                } else {
                    console.warn('No se pudieron cargar los datos de pronóstico. Usando datos de ejemplo.');
                    forecastData = sampleForecastData;
                    processForecastData();
                }
                
                // Llenar el selector de símbolos
                populateSymbolSelector();
                
                // Actualizar gráficos con el primer símbolo disponible
                if (currentSymbol) {
                    updateAllCharts();
                }
                
            } catch (error) {
                console.error('Error:', error);
                alert('Error al cargar los datos. Por favor, revise la consola para más detalles.');
            }
        }

        // Procesar datos históricos
        function processHistoricalData() {
            // Agrupar datos por símbolo y convertir formatos de fecha
            historicalData.forEach(item => {
                // Crear una fecha completa a partir de los campos separados
                const [year, month, day] = item.fecha.split('-');
                item.fullDate = new Date(
                    parseInt(year), 
                    parseInt(month) - 1, 
                    parseInt(day),
                    item.hora,
                    item.minuto
                );
                
                // Convertir campos numéricos
                item.fin = parseFloat(item.fin);
                item.open = parseFloat(item.open);
                item.high = parseFloat(item.high);
                item.low = parseFloat(item.low);
                item.volume = parseFloat(item.volume);
            });
        }

        // Procesar datos de pronóstico
        function processForecastData() {
            forecastData.forEach(item => {
                // Convertir fecha
                const [year, month, day] = item.Fecha.split('-');
                item.fullDate = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
                
                // Convertir campos numéricos
                item.Prophet_Forecast = parseFloat(item.Prophet_Forecast);
                item.Regresion_Linear_Forecast = parseFloat(item.Regresion_Linear_Forecast);
                item.ARIMA_Forecast = parseFloat(item.ARIMA_Forecast);
                item.RNN_Forecast = parseFloat(item.RNN_Forecast);
            });
        }

        // Llenar el selector de símbolos
        function populateSymbolSelector() {
            const selector = document.getElementById('symbol-selector');
            selector.innerHTML = '';
            
            // Obtener símbolos únicos de los datos históricos
            const symbols = [...new Set(historicalData.map(item => item.symbol))];
            
            symbols.forEach(symbol => {
                const option = document.createElement('option');
                option.value = symbol;
                option.textContent = symbol;
                selector.appendChild(option);
            });
            
            // Seleccionar el primer símbolo por defecto
            if (symbols.length > 0) {
                currentSymbol = symbols[0];
                selector.value = currentSymbol;
            }
        }

        // Mostrar estado de carga
        function showLoadingState() {
            const charts = ['price-chart', 'forecast-chart', 'volume-chart'];
            
            charts.forEach(chartId => {
                const chartElement = document.getElementById(chartId);
                chartElement.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <div>Cargando datos...</div>
                    </div>
                `;
            });
            
            // Establecer valores por defecto en los KPIs
            document.querySelectorAll('.kpi-value').forEach(el => {
                el.textContent = '--';
            });
            
            document.querySelectorAll('.kpi-change').forEach(el => {
                el.textContent = '--';
            });
        }

        // Actualizar todos los gráficos
        function updateAllCharts() {
            updateKPIs();
            updatePriceChart();
            updateForecastChart();
            updateVolumeChart();
        }

        // Actualizar KPIs
        function updateKPIs() {
            if (!historicalData || !forecastData) return;
            
            // Filtrar datos para el símbolo actual
            const symbolHistoricalData = historicalData.filter(item => item.symbol === currentSymbol);
            const symbolForecastData = forecastData.filter(item => item.symbol === currentSymbol);
            
            if (symbolHistoricalData.length === 0) return;
            
            // Obtener el último dato histórico
            const latestData = symbolHistoricalData[symbolHistoricalData.length - 1];
            
            // Obtener el dato anterior para calcular cambios
            const previousData = symbolHistoricalData[symbolHistoricalData.length - 2];
            
            // Calcular cambio de precio
            let priceChange = 0;
            let priceChangePercent = 0;
            
            if (previousData) {
                priceChange = latestData.fin - previousData.fin;
                priceChangePercent = (priceChange / previousData.fin) * 100;
            }
            
            // Actualizar KPI de precio
            document.getElementById('current-price').textContent = latestData.fin.toFixed(2);
            const priceChangeElement = document.getElementById('price-change');
            priceChangeElement.textContent = 
                `${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(2)} (${priceChangePercent >= 0 ? '+' : ''}${priceChangePercent.toFixed(2)}%)`;
            priceChangeElement.className = `kpi-change ${priceChange >= 0 ? 'positive' : 'negative'}`;
            
            // Calcular cambio de volumen
            let volumeChange = 0;
            let volumeChangePercent = 0;
            
            if (previousData) {
                volumeChange = latestData.volume - previousData.volume;
                volumeChangePercent = (volumeChange / previousData.volume) * 100;
            }
            
            // Actualizar KPI de volumen
            document.getElementById('current-volume').textContent = latestData.volume.toLocaleString();
            const volumeChangeElement = document.getElementById('volume-change');
            volumeChangeElement.textContent = 
                `${volumeChange >= 0 ? '+' : ''}${volumeChange.toLocaleString()} (${volumeChangePercent >= 0 ? '+' : ''}${volumeChangePercent.toFixed(2)}%)`;
            volumeChangeElement.className = `kpi-change ${volumeChange >= 0 ? 'positive' : 'negative'}`;
            
            // Obtener el último pronóstico disponible
            if (symbolForecastData.length > 0) {
                const latestForecast = symbolForecastData[symbolForecastData.length - 1];
                
                // Calcular cambios para Prophet
                const prophetChange = latestForecast.Prophet_Forecast - latestData.fin;
                const prophetChangePercent = (prophetChange / latestData.fin) * 100;
                
                document.getElementById('prophet-forecast').textContent = latestForecast.Prophet_Forecast.toFixed(2);
                const prophetChangeElement = document.getElementById('prophet-change');
                prophetChangeElement.textContent = 
                    `${prophetChange >= 0 ? '+' : ''}${prophetChange.toFixed(2)} (${prophetChangePercent >= 0 ? '+' : ''}${prophetChangePercent.toFixed(2)}%)`;
                prophetChangeElement.className = `kpi-change ${prophetChange >= 0 ? 'positive' : 'negative'}`;
                
                // Calcular cambios para RNN
                const rnnChange = latestForecast.RNN_Forecast - latestData.fin;
                const rnnChangePercent = (rnnChange / latestData.fin) * 100;
                
                document.getElementById('rnn-forecast').textContent = latestForecast.RNN_Forecast.toFixed(2);
                const rnnChangeElement = document.getElementById('rnn-change');
                rnnChangeElement.textContent = 
                    `${rnnChange >= 0 ? '+' : ''}${rnnChange.toFixed(2)} (${rnnChangePercent >= 0 ? '+' : ''}${rnnChangePercent.toFixed(2)}%)`;
                rnnChangeElement.className = `kpi-change ${rnnChange >= 0 ? 'positive' : 'negative'}`;
            }
        }

        // Actualizar gráfico de precios
        function updatePriceChart() {
            if (!historicalData) return;
            
            // Filtrar datos para el símbolo actual
            let symbolHistoricalData = historicalData.filter(item => item.symbol === currentSymbol);
            
            if (symbolHistoricalData.length === 0) return;
            
            // Aplicar filtro de tiempo
            const timeFilter = document.getElementById('time-filter').value;
            const filterDays = parseInt(timeFilter);
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - filterDays);
            
            symbolHistoricalData = symbolHistoricalData.filter(item => item.fullDate >= cutoffDate);
            
            // Preparar datos para el gráfico
            const dates = symbolHistoricalData.map(item => item.fullDate);
            const prices = symbolHistoricalData.map(item => item.fin);
            
            // Configuración del gráfico
            const options = {
                series: [{
                    name: 'Precio de cierre',
                    data: prices.map((price, index) => ({
                        x: dates[index],
                        y: price
                    }))
                }],
                chart: {
                    type: 'area',
                    height: '100%',
                    background: 'transparent',
                    foreColor: chartColors.text,
                    toolbar: {
                        show: true,
                        tools: {
                            download: false,
                            selection: true,
                            zoom: true,
                            zoomin: true,
                            zoomout: true,
                            pan: true,
                            reset: true
                        }
                    },
                    zoom: {
                        enabled: true,
                        type: 'x',
                        autoScaleYaxis: true
                    },
                    animations: {
                        enabled: true,
                        easing: 'easeinout',
                        speed: 800
                    }
                },
                colors: [chartColors.line],
                dataLabels: {
                    enabled: false
                },
                stroke: {
                    curve: 'smooth',
                    width: 2
                },
                fill: {
                    type: 'gradient',
                    gradient: {
                        shadeIntensity: 0.5,
                        opacityFrom: 0.6,
                        opacityTo: 0.1,
                        stops: [0, 90, 100]
                    }
                },
                grid: {
                    borderColor: chartColors.grid,
                    strokeDashArray: 3,
                    padding: {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    }
                },
                xaxis: {
                    type: 'datetime',
                    axisBorder: {
                        color: chartColors.grid
                    },
                    axisTicks: {
                        color: chartColors.grid
                    }
                },
                yaxis: {
                    opposite: true,
                    labels: {
                        formatter: function(val) {
                            return val.toFixed(2);
                        }
                    },
                    tooltip: {
                        enabled: true
                    }
                },
                tooltip: {
                    x: {
                        format: 'dd MMM yyyy HH:mm'
                    }
                }
            };
            
            // Renderizar o actualizar el gráfico
            if (priceChart) {
                priceChart.updateOptions(options);
            } else {
                priceChart = new ApexCharts(document.querySelector("#price-chart"), options);
                priceChart.render();
            }
        }

        // Actualizar gráfico de pronósticos
        function updateForecastChart() {
            if (!forecastData) return;
            
            // Filtrar datos para el símbolo actual y los días 15-17
            let symbolForecastData = forecastData.filter(item => 
                item.symbol === currentSymbol
            );
            
            // Obtener días 15, 16 y 17
            const targetDates = [];
            const now = new Date();
            
            for (let i = 15; i <= 17; i++) {
                const date = new Date(now);
                date.setDate(now.getDate() + i);
                targetDates.push(date.toISOString().split('T')[0]);
            }
            
            symbolForecastData = symbolForecastData.filter(item => {
                const itemDate = item.fullDate.toISOString().split('T')[0];
                return targetDates.includes(itemDate);
            });
            
            if (symbolForecastData.length === 0) {
                // Si no hay datos para los días 15-17, mostrar los últimos 3 días disponibles
                symbolForecastData = forecastData.filter(item => item.symbol === currentSymbol);
                symbolForecastData = symbolForecastData.slice(-3);
            }
            
            if (symbolForecastData.length === 0) return;
            
            // Preparar datos para el gráfico
            const series = [
                {
                    name: 'Prophet',
                    data: symbolForecastData.map(item => ({
                        x: item.fullDate,
                        y: item.Prophet_Forecast
                    }))
                },
                {
                    name: 'Regresión Lineal',
                    data: symbolForecastData.map(item => ({
                        x: item.fullDate,
                        y: item.Regresion_Linear_Forecast
                    }))
                },
                {
                    name: 'ARIMA',
                    data: symbolForecastData.map(item => ({
                        x: item.fullDate,
                        y: item.ARIMA_Forecast
                    }))
                },
                {
                    name: 'RNN',
                    data: symbolForecastData.map(item => ({
                        x: item.fullDate,
                        y: item.RNN_Forecast
                    }))
                }
            ];
            
            // Configuración del gráfico
            const options = {
                series: series,
                chart: {
                    type: 'line',
                    height: '100%',
                    background: 'transparent',
                    foreColor: chartColors.text,
                    toolbar: {
                        show: false
                    },
                    animations: {
                        enabled: true,
                        easing: 'easeinout',
                        speed: 800
                    }
                },
                colors: [chartColors.prophet, chartColors.linear, chartColors.arima, chartColors.rnn],
                dataLabels: {
                    enabled: false
                },
                stroke: {
                    curve: 'smooth',
                    width: 2
                },
                grid: {
                    borderColor: chartColors.grid,
                    strokeDashArray: 3,
                    padding: {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    }
                },
                xaxis: {
                    type: 'datetime',
                    axisBorder: {
                        color: chartColors.grid
                    },
                    axisTicks: {
                        color: chartColors.grid
                    },
                    labels: {
                        format: 'dd MMM'
                    }
                },
                yaxis: {
                    opposite: true,
                    labels: {
                        formatter: function(val) {
                            return val.toFixed(2);
                        }
                    },
                    tooltip: {
                        enabled: true
                    }
                },
                tooltip: {
                    x: {
                        format: 'dd MMM yyyy'
                    }
                },
                legend: {
                    position: 'top',
                    horizontalAlign: 'right'
                }
            };
            
            // Renderizar o actualizar el gráfico
            if (forecastChart) {
                forecastChart.updateOptions(options);
            } else {
                forecastChart = new ApexCharts(document.querySelector("#forecast-chart"), options);
                forecastChart.render();
            }
        }

        // Actualizar gráfico de volumen
        function updateVolumeChart() {
            if (!historicalData) return;
            
            // Filtrar datos para el símbolo actual
            let symbolHistoricalData = historicalData.filter(item => item.symbol === currentSymbol);
            
            if (symbolHistoricalData.length === 0) return;
            
            // Aplicar filtro de tiempo (mismo que para el gráfico de precios)
            const timeFilter = document.getElementById('time-filter').value;
            const filterDays = parseInt(timeFilter);
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - filterDays);
            
            symbolHistoricalData = symbolHistoricalData.filter(item => item.fullDate >= cutoffDate);
            
            // Preparar datos para el gráfico
            const dates = symbolHistoricalData.map(item => item.fullDate);
            const volumes = symbolHistoricalData.map(item => item.volume);
            
            // Configuración del gráfico
            const options = {
                series: [{
                    name: 'Volumen',
                    data: volumes.map((volume, index) => ({
                        x: dates[index],
                        y: volume
                    }))
                }],
                chart: {
                    type: 'bar',
                    height: '100%',
                    background: 'transparent',
                    foreColor: chartColors.text,
                    toolbar: {
                        show: false
                    },
                    animations: {
                        enabled: true,
                        easing: 'easeinout',
                        speed: 800
                    }
                },
                colors: [chartColors.volume],
                dataLabels: {
                    enabled: false
                },
                grid: {
                    borderColor: chartColors.grid,
                    strokeDashArray: 3,
                    padding: {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    }
                },
                xaxis: {
                    type: 'datetime',
                    axisBorder: {
                        color: chartColors.grid
                    },
                    axisTicks: {
                        color: chartColors.grid
                    }
                },
                yaxis: {
                    opposite: true,
                    labels: {
                        formatter: function(val) {
                            if (val >= 1000000) {
                                return (val / 1000000).toFixed(1) + 'M';
                            } else if (val >= 1000) {
                                return (val / 1000).toFixed(1) + 'K';
                            }
                            return val;
                        }
                    }
                },
                tooltip: {
                    x: {
                        format: 'dd MMM yyyy HH:mm'
                    },
                    y: {
                        formatter: function(val) {
                            return val.toLocaleString();
                        }
                    }
                },
                plotOptions: {
                    bar: {
                        borderRadius: 3,
                        columnWidth: '60%'
                    }
                }
            };
            
            // Renderizar o actualizar el gráfico
            if (volumeChart) {
                volumeChart.updateOptions(options);
            } else {
                volumeChart = new ApexCharts(document.querySelector("#volume-chart"), options);
                volumeChart.render();
            }
        }
    </script>
</body>
</html>
